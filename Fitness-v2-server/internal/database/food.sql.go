// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: food.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createFood = `-- name: CreateFood :one
INSERT INTO food_items (
    name, 
    description, 
    image_url, 
    food_type, 
    calories, 
    fat, 
    protein, 
    carbs
  ) 
VALUES (
  $1, 
  $2, 
  $3, 
  $4, 
  $5, 
  $6, 
  $7, 
  $8
) 
RETURNING id, name, description, image_url, food_type, calories, fat, protein, carbs, created_at, updated_at
`

type CreateFoodParams struct {
	Name        string
	Description sql.NullString
	ImageUrl    sql.NullString
	FoodType    FoodItemType
	Calories    string
	Fat         string
	Protein     string
	Carbs       string
}

func (q *Queries) CreateFood(ctx context.Context, arg CreateFoodParams) (FoodItem, error) {
	row := q.db.QueryRowContext(ctx, createFood,
		arg.Name,
		arg.Description,
		arg.ImageUrl,
		arg.FoodType,
		arg.Calories,
		arg.Fat,
		arg.Protein,
		arg.Carbs,
	)
	var i FoodItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.FoodType,
		&i.Calories,
		&i.Fat,
		&i.Protein,
		&i.Carbs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteFoodItem = `-- name: DeleteFoodItem :one
DELETE FROM food_items
WHERE id = $1
RETURNING id, name, description, image_url, food_type, calories, fat, protein, carbs, created_at, updated_at
`

func (q *Queries) DeleteFoodItem(ctx context.Context, id uuid.UUID) (FoodItem, error) {
	row := q.db.QueryRowContext(ctx, deleteFoodItem, id)
	var i FoodItem
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.ImageUrl,
		&i.FoodType,
		&i.Calories,
		&i.Fat,
		&i.Protein,
		&i.Carbs,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFoodItemsByMealID = `-- name: GetFoodItemsByMealID :many
SELECT rmf.meal_id, rmf.food_item_id, rmf.user_id, rmf.amount, fi.id, fi.name, fi.description, fi.image_url, fi.food_type, fi.calories, fi.fat, fi.protein, fi.carbs, fi.created_at, fi.updated_at
FROM rel_meal_food rmf
LEFT JOIN food_items fi ON fi.id = rmf.food_item_id
WHERE rmf.meal_id = $1
AND rmf.user_id = $2
`

type GetFoodItemsByMealIDParams struct {
	MealID uuid.UUID
	UserID uuid.UUID
}

type GetFoodItemsByMealIDRow struct {
	MealID      uuid.UUID
	FoodItemID  uuid.UUID
	UserID      uuid.UUID
	Amount      sql.NullInt32
	ID          uuid.NullUUID
	Name        sql.NullString
	Description sql.NullString
	ImageUrl    sql.NullString
	FoodType    NullFoodItemType
	Calories    sql.NullString
	Fat         sql.NullString
	Protein     sql.NullString
	Carbs       sql.NullString
	CreatedAt   sql.NullTime
	UpdatedAt   sql.NullTime
}

func (q *Queries) GetFoodItemsByMealID(ctx context.Context, arg GetFoodItemsByMealIDParams) ([]GetFoodItemsByMealIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getFoodItemsByMealID, arg.MealID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFoodItemsByMealIDRow
	for rows.Next() {
		var i GetFoodItemsByMealIDRow
		if err := rows.Scan(
			&i.MealID,
			&i.FoodItemID,
			&i.UserID,
			&i.Amount,
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.FoodType,
			&i.Calories,
			&i.Fat,
			&i.Protein,
			&i.Carbs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoodItemsTotalPages = `-- name: GetFoodItemsTotalPages :one
SELECT COUNT(*) AS total_pages
FROM food_items
`

func (q *Queries) GetFoodItemsTotalPages(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFoodItemsTotalPages)
	var total_pages int64
	err := row.Scan(&total_pages)
	return total_pages, err
}

const getFoodItemsTotalPagesWithFilter = `-- name: GetFoodItemsTotalPagesWithFilter :one
SELECT COUNT(*) AS total_pages
FROM food_items
WHERE name ILIKE '%' || $1 || '%'
`

func (q *Queries) GetFoodItemsTotalPagesWithFilter(ctx context.Context, dollar_1 sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFoodItemsTotalPagesWithFilter, dollar_1)
	var total_pages int64
	err := row.Scan(&total_pages)
	return total_pages, err
}

const getFoods = `-- name: GetFoods :many
SELECT id, name, description, image_url, food_type, calories, fat, protein, carbs, created_at, updated_at FROM food_items 
ORDER BY name ASC
LIMIT $1
OFFSET $2
`

type GetFoodsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetFoods(ctx context.Context, arg GetFoodsParams) ([]FoodItem, error) {
	rows, err := q.db.QueryContext(ctx, getFoods, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FoodItem
	for rows.Next() {
		var i FoodItem
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.FoodType,
			&i.Calories,
			&i.Fat,
			&i.Protein,
			&i.Carbs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFoodsWithFilter = `-- name: GetFoodsWithFilter :many
SELECT id, name, description, image_url, food_type, calories, fat, protein, carbs, created_at, updated_at FROM food_items 
WHERE name ILIKE '%' || $3 || '%'
ORDER BY name ASC
LIMIT $1
OFFSET $2
`

type GetFoodsWithFilterParams struct {
	Limit   int32
	Offset  int32
	Column3 sql.NullString
}

func (q *Queries) GetFoodsWithFilter(ctx context.Context, arg GetFoodsWithFilterParams) ([]FoodItem, error) {
	rows, err := q.db.QueryContext(ctx, getFoodsWithFilter, arg.Limit, arg.Offset, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FoodItem
	for rows.Next() {
		var i FoodItem
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.ImageUrl,
			&i.FoodType,
			&i.Calories,
			&i.Fat,
			&i.Protein,
			&i.Carbs,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
